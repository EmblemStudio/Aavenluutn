//SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import "hardhat/console.sol";

import "@openzeppelin/contracts/utils/Counters.sol";
import "./NarrativeManager.sol";
import "./Narrators.sol";

contract NarrativeAuctionHouse is ERC721Enumerable {
    using Counters for Counters.Counter;

    constructor(
        address _narrativeManager,
        uint256 _timeBuffer,
        uint256 _baseAuctionDuration,
        uint256 _minBidAmount,
        uint8 _minBidIncrementPercentage,
        string memory name,
        string memory symbol
    ) ERC721(name, symbol) {
        narrativeManager = NarrativeManager(_narrativeManager);
        timeBuffer = _timeBuffer;
        baseAuctionDuration = _baseAuctionDuration;
        minBidAmount = _minBidAmount;
        minBidIncrementPercentage = _minBidIncrementPercentage;
    }

    function _auctionTimeLeft(bytes32 narrativeId) internal view returns (uint256) {
        // returns max uint256 if the auction is not open, and time left if it is
        Narrative memory narrative = narratives[narrativeId];
        narrativeManager.narrators(narrative.narratorIndex);
        Narrators.Narrator memory narrator = Narrators.Narrator();
        uint256 narrativeStart = Narrators.narrativeStartTime(narrator, narrative.index, narrative.copyIndex);
        uint256 narrativeEnd = narrativeStart + narrator.narrativeLength;
        if (narrativeEnd < block.timestamp) {
            return type(uint256).max; // Narrative hasn't ended yet, auction not open
        }
        uint256 auctionEnd = narrativeEnd + narrative.auction.duration;
        if (auctionEnd > block.timestamp) {
            return 0; // Auction has ended
        }
        return auctionEnd - block.timestamp;
    }

    function getNarrativeId(
        uint256 narratorIndex,
        uint256 narrativeIndex,
        uint256 copyIndex
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(narratorIndex, narrativeIndex, copyIndex));
    }

    event Bid(bytes32 narrativeId, uint256 amount, address bidder);
    event AuctionExtended(bytes32 narrativeId, uint256 newDuration);

    function bid(
        uint256 narratorIndex,
        uint256 narrativeIndex,
        uint256 copyIndex,
        address mintTo,
        uint256 amount
    ) external payable {
        require(msg.value == amount, "Sent ETH value must match bid amount");
        require(mintTo != address(0), "Invalid mintTo address");
        require(amount >= minBidAmount, "Bid below minimum bid amount");

        bytes32 narrativeId = getNarrativeId(narratorIndex, narrativeIndex, copyIndex);
        Narrative storage narrative = narratives[narrativeId];

        // initialize the narrative and auction if needed
        if (narrative.auction.bidder == address(0)) {
            narrative.narratorIndex = narratorIndex;
            narrative.index = narrativeIndex;
            narrative.copyIndex = copyIndex;
            narrative.auction.amount = amount;
            narrative.auction.bidder = payable(msg.sender);
            narrative.auction.duration = baseAuctionDuration;
        }
        uint256 timeLeft = _auctionTimeLeft(narrativeId);
        require(timeLeft > 0 && timeLeft < type(uint256).max, "Auction not open");
        uint256 minIncrement = (narrative.auction.amount * minBidIncrementPercentage) / 100;
        require(amount >= narrative.auction.amount + minIncrement, "Bid increment too low");

        // TODO implement WETH backup transfer

        // extend the auction if needed
        if (timeLeft < timeBuffer) {
            narrative.auction.duration += (timeBuffer - timeLeft);
            emit AuctionExtended(narrativeId, narrative.auction.duration);
        }

        // set current bidder as winning bidder
        // TODO add reentrency guard
        narrative.auction.bidder = payable(msg.sender);
        narrative.auction.amount = amount;
        emit Bid(narrativeId, amount, msg.sender);

        // return previous bidder their bid
        (bool success,) = narrative.auction.bidder.call{
            value: narrative.auction.amount
        }(new bytes(0));
    }

    function mint(
        uint256 narratorIndex,
        uint256 narrativeIndex,
        uint256 copyIndex,
        address to
    ) public {
        require(to != address(0), "Invalid to address");
        bytes32 narrativeId = getNarrativeId(narratorIndex, narrativeIndex, copyIndex);
        require(_auctionTimeLeft(narrativeId) == 0, "Auction not finished");
        Narrative memory narrative = narratives[narrativeId];

        // if someone bid, require sender to have won auction
        if(narrative.auction.bidder != address(0)) {
            require(msg.sender == narrative.auction.bidder);
        } // otherwise fine you can mint

        // mint
        _mint(to, nftIds.current());
        mintedNarratives[nftIds.current()] = narrativeId;
        nftIds.increment();
    }

    function tokenURI(uint256 nftId) public view virtual override returns (string memory) {
        require(_exists(nftId), "NarrativeAuctionHouse.tokenURI id does not exist");
        string memory narrativeId = string(abi.encodePacked(mintedNarratives[nftId]));
        return string(abi.encodePacked("data:", narrativeId));
    }
}
